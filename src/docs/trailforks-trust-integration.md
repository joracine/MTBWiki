# Trailforks Trust Score Integration Analysis

## What is Trailforks Trust Score?

Trailforks uses a Trust score system to evaluate user credibility based on:
- Quality of trail reports and updates
- Accuracy of submitted data
- Community feedback on contributions
- Consistency over time
- Local knowledge demonstrated

This is exactly the kind of credibility system that would be valuable for MTB Wiki!

## API Access Challenges

### Likely Limitations
Most APIs, especially for user data, have significant restrictions:

```typescript
// What we'd LOVE to access (probably not available)
interface TrailforksUserData {
  username: string;
  trust_score: number;
  contributions_count: number;
  local_areas: string[];
  verified_local_regions: string[];
}
```

### Privacy and Legal Barriers
- **User Privacy**: Trust scores are sensitive user data
- **OAuth Scope**: Would require explicit user permission
- **Business Protection**: Trailforks likely protects this competitive data
- **Terms of Service**: User data access is typically restricted

## Potential Integration Approaches

### 1. **OAuth + Limited Profile Access**
```typescript
// What might be possible with user consent
interface TrailforksProfile {
  username: string;
  public_profile_url: string;
  verified_regions?: string[]; // If they make this public
  // Trust score probably NOT included
}

// Integration flow
async function linkTrailforksAccount(userId: string) {
  // User authorizes MTB Wiki to access their TF profile
  const tfProfile = await trailforksOAuth.getProfile();
  
  // Store minimal reference data
  return {
    user_id: userId,
    trailforks_username: tfProfile.username,
    trailforks_profile_url: tfProfile.public_profile_url,
    verified_at: new Date(),
    // No trust score - we'd build our own
  };
}
```

### 2. **Manual Verification Process**
```typescript
interface TrailforksVerification {
  user_id: string;
  trailforks_username: string;
  verification_method: 'profile_link' | 'mutual_confirmation' | 'moderator_check';
  
  // What we can infer from public profile
  apparent_local_regions: string[];
  contribution_indicators: {
    has_trail_reports: boolean;
    has_photos: boolean;
    profile_completeness: 'basic' | 'detailed' | 'comprehensive';
  };
  
  verified_by: string; // MTB Wiki user who confirmed
  verification_date: Date;
}
```

### 3. **Hybrid Credibility System**
```typescript
interface UserCredibility {
  // Our own system
  mtb_wiki_reputation: number;
  local_verifications: LocalCredibility[];
  contribution_quality: number;
  
  // External indicators (what we can get)
  external_profiles: {
    trailforks?: {
      username: string;
      profile_url: string;
      // Can't get trust score, but can reference it exists
      has_established_profile: boolean;
    };
    strava?: {
      athlete_id: string;
      // Similar limitations
    };
  };
}
```

## Alternative Credibility Strategies

### 1. **Cross-Platform Verification**
```typescript
// User proves they control accounts on multiple platforms
interface CrossPlatformVerification {
  verification_code: string; // Generated by MTB Wiki
  
  platforms: {
    trailforks?: {
      username: string;
      verification_method: 'bio_update' | 'private_message';
      verified: boolean;
    };
    strava?: {
      athlete_id: string;
      verification_method: 'activity_title' | 'bio_update';
      verified: boolean;
    };
    instagram?: {
      handle: string;
      verification_method: 'story_post' | 'bio_update';
      verified: boolean;
    };
  };
}
```

### 2. **Local Community Vouching**
```typescript
interface CommunityVouching {
  user_id: string;
  system_id: string;
  
  vouchers: {
    voucher_user_id: string;
    voucher_credibility: number;
    relationship: 'ride_buddy' | 'local_shop' | 'trail_builder' | 'club_member';
    vouch_strength: 'weak' | 'moderate' | 'strong';
    comments: string;
    date: Date;
  }[];
  
  // Calculated credibility
  community_trust_score: number;
}
```

### 3. **Progressive Trust Building**
```typescript
interface ProgressiveTrust {
  user_id: string;
  
  trust_factors: {
    // Time-based
    account_age_months: number;
    consistent_activity: boolean;
    
    // Quality-based
    peer_review_average: number;
    fact_check_success_rate: number;
    helpful_vote_ratio: number;
    
    // Local knowledge
    local_verifications: number;
    system_expertise_count: number;
    
    // External validation
    verified_external_accounts: number;
    cross_platform_consistency: boolean;
  };
  
  calculated_trust_level: 'new' | 'established' | 'trusted' | 'expert';
}
```

## Recommended Implementation

### Phase 1: Start Simple
```typescript
interface BasicCredibility {
  // Manual verification
  claimed_local_areas: string[];
  trailforks_username?: string; // User provides, we verify exists
  
  // Our own metrics
  contributions_count: number;
  quality_score_average: number;
  community_vouches: number;
  
  // Simple trust level
  trust_level: 'new' | 'contributing' | 'trusted' | 'expert';
}
```

### Phase 2: Enhanced Verification
- Cross-platform account linking
- Community vouching system
- Progressive trust building
- Local bike shop verification

### Phase 3: Potential API Integration
- IF Trailforks opens up user data access
- OAuth flow for willing users
- Respect all privacy concerns

## Code Example: Practical Implementation

```typescript
// Trailforks profile verification (no API needed)
async function verifyTrailforksProfile(username: string): Promise<boolean> {
  try {
    // Check if public profile exists
    const response = await fetch(`https://www.trailforks.com/user/${username}/`);
    return response.status === 200;
  } catch {
    return false;
  }
}

// Build credibility without external APIs
function calculateCredibility(user: User): CredibilityScore {
  let score = 0;
  
  // Time factor
  const monthsActive = getMonthsSince(user.created_at);
  score += Math.min(monthsActive * 2, 20);
  
  // Quality contributions
  score += user.quality_contributions * 5;
  
  // Local verifications
  score += user.local_verifications.length * 10;
  
  // Community vouches
  score += user.community_vouches * 3;
  
  // External profile verification
  if (user.verified_trailforks_profile) score += 15;
  if (user.verified_strava_profile) score += 10;
  
  return {
    score: Math.min(score, 100),
    level: getCredibilityLevel(score),
    factors: getScoreBreakdown(user)
  };
}
```

## Conclusion

While direct access to Trailforks Trust scores is unlikely due to privacy and business reasons, we can:

1. **Verify account ownership** (user claims to be X on Trailforks)
2. **Check profile existence** (confirm the account exists and is active)
3. **Build our own trust system** based on MTB Wiki contributions
4. **Use cross-platform verification** to establish authenticity
5. **Leverage community vouching** for local credibility

The key is building a credibility system that's **complementary** to Trailforks rather than dependent on it. This also gives you more control and reduces external dependencies.

Would you like me to design a specific credibility algorithm that combines these approaches? 